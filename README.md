# Dynamic NFTs

## Documentation

Documentation can be found in each subfolder:

- [Companion](companion/README.md)
- [Contracts](contracts/README.md)
- [dApp](dapp/README.md)
- [Chainlink Functions](functions/README.md)

## Project Description

I wanted to demonstrate the power of off-chain processing linked with oracle consensus. While this solution isn't perfect, proving execution with zk proofs is still orders of magnitude more expensive than actually running the code itself. Thus, tools like Chainlink Functions provide a good tradeoff between correctness, decentralization and cost in my opinion.

To demonstrate this, I chose to build generative NFTs, as they can be used as a visual and intuitive example. My goal was to be as decentralized, generic and open as possible. This means that the code used to generate the images is public and portable, and can be ran by the Chainlink Function itself, by a NodeJS or Deno script and directly in the browser. If the IPFS hash ever came to disappear from the network, it would be trivial for any user to regenerate the image, upload it to Filecoin or pin it on IPFS, which would immediately make it available universally again (like NFT marketplaces for example). Alternatively, the full library can also be rendered directly in the browser without any need to store the generated data.

The beauty of this project is that the NFTs are simply represented by a file with three functions, an example of which can be found in [`generate.js`](functions/generate.js).

## How it's Made

The NFTs are represented by:

- Standalone code that generates the image based on a seed and arguments
- Standalone code that generates the metadata based on a seed and arguments
- A canonical CID generated by the aforementioned pieces of code
- A Chainlink Function that generates the image and metadata and posts the resulting IPFS CIDs on chain
- A smart contract that sets the random values on mint and keeps track of the canonical CIDs for each token

In addition to this, a companion app independently generates the image and metadata and uploads them to Filecoin. While the smart contract is intentionally kept simple without VRF, the latter would be trivial to implement in addition to the rest.

When a mint happens, a call is directly made to the Chainlink Function, which executes the code based on a random seed and arguments. The arguments can be used to set specific parameters. For example, a user could pay extra to get a higher rarity or set specific properties on the token, rather than it being fully random. The seed is the same for the image and metadata generation, which allows properties to be set and defined in both the image and the metadata. Once the code is executed, the Function computes the CID of the metadata (which includes the CID of the image) and posts the result to the smart contract.

In parallel to that, a companion app does the exact same process, but also uploads the result to Filecoin to make it available to everyone. While this could also have been done in the Chainlink Function, my intention was to keep the latter as simple as possible and decouple the long-term storage cost from the minting cost. If a user wants their NFT to persist longer than initially anticipated, they are free to do so at their own charge.

As the code can also run in the browser, itâ€™s also possible to render the full library directly on a website, as shown in the dApp linked to this project. This allows the project to live on eternally, even if the data disappears from IPFS or the protocol ceases to exist.
